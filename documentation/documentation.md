# The Kang2 Programming Language

## Table of Contents

1. [Introdcuction](#introduction)
2. [How it works](#how-it-works)
2. [In- and Output](#in--and-output)
3. [Variables](#variables)
4. [Comparisons](#comparisons)
5. [Conditions](#conditions)
6. [Loops](#loops)
7. [Functions](#functions)
7. [Summary](#summary)

<br>

---

<br>

## Introduction

<br>

**Kang2** is a high-level, easy to learn programming language. It combines many loved features of other popular languages, while adding new and exciting ideas for future languages to come. It uses NodeJS and is best used for small terminal applications and to see, how a interpreter works under the hood. It's relatively small size makes it easy to tinker with and make new additions.

<br>


<br>


To use the language, a download first at:

https://nodejs.org/en/download/

Then use the `node ['filename']`  command, to run the `app.js` file, which is locate inside the `src` directory.

The file that is run is called `test.kg`, but can be manually changed in the file called `readFile.js`, inside the `testing` directory. 

Now some code can be written.

<br>

---

<br>


## How it works

This section is going to get into how some things work, which might be important to know for more experienced developers. A Beginner can skip this for now and move on to the other things.

Basically one block of code is called a **Statement**. This can be everything from just a small `"Hello World!"` Output, to a whole giant function. These **Statements** are saved into a **Statement Sequence**, which is just a list of **Statements**. Now what's important is that every **Statement Sequence** has it's own **Symbol Table**, which means it saves new Variables locally. This Table has a reference to it's parent, but not backwards. So it's just going upwards.

This is easily represented by a **Function**, within the global scope. We'll just call it `getSmt()`. If a **Variable** is now declared outside `getSmt`, then itself and all other **Functions** gave access to it, due to them having a reference, to their parents Table, which now translates to the global scope. But if a **Variable** is declared within `getSmt`, then just it has access, because the parent, doesn't have a reference, therefore it doesn't know it exists.

Everytime a **Funtion** is called, a new Table is created. This also counts for **Loops** and **Conditions**. This also means, that a Variable inside a function can only be taken out by either a `return` or a mutation of another Variable, which lies higher in the Table-Tree.

Now going back, every **Function** has it's own **Statement Sequence**, which holds it's own **Symbol Table**. The global scope itself can be seen as a big **Function**, which is just called instantely.

With that said, the language has a hierarchy. At the top is the **Statment Sequence**, with the **Statement** just below that. Up until now, there is only a total of eight possible **Statements**. These include:

- Assigning a new Variable
- Creating a new Function
- Mutating an existing Variable
- Logging Something
- Returning anything
- Getting Input
- Invoking a Loop
- Checking a Condition

If there is not one of those written, it will lead to an **error**.

Below that is the **Expression**. One of those is used, when there is any type of value, like an **argument** or the value for a new **Variable**. This part of the hierarchy is there to provide calculations, that are done right. Here we have:

- Addition
- Subtraction
- Any type of comparison

After that comes the second to last one, which is the **Term**. This includes:

- Multiplication
- Division
- Modulo

And the last one is the **Factor**. This one has:

- Positive and negative numbers
- Partenthesis
- Strings
- Variable references
- Function calls
- Booleans

All these layers are there to provide a foundation, on which to build an easy to understand **parser**, which takes all the tokens, generated by the **lexer** and turning them into a huge **Syntax Tree**

To calculate all multiplications before any additions for example, every **Node** in the Tree has one purpose, like adding two Numbers. Now the **Interpreter**, which traverses this tree through every branch, sees that two **Nodes** have to be added together and opens them up. Inside it finds a multiplication with two other **Nodes**. And he opens them up again. Now he finds just a **Number**. This Number is then `returned` and multiplied with the other one. The Result is now added to the other one and we have our addition, with the multiplication being done first.

While the Interpreter goes inside every **Node**, like creating a new **Variable** or calling a **Function** in the end, it went through every branch and is done.

All this may be a bit complicated, but once the basics get into someones head, it's actually way easier than the general assumption is.

<br>

---

<br>

## In- and Output


**Output** is gotten, by using the `log` keyword
```swift
log "Hello World!"

// CONSOLE
Hello World!
```


To get **Input**, the `input` keyword needs to be used

```swift
input "Name?"

// CONSOLE
>> Name?
```

> Both `log` and `input` are not functions though, they cannot be invoked in a calculation and do not return anything. They are statements

`input` can be saved is saves with the **arrow**
```swift
var name
input "Name? " -> name

input "Age? " -> var age


log name
log age

// CONSOLE
>> Name? acho
>> Age?  18

"acho"
18
```

<br>

---

<br>

## Variables

Variables in Kang2 are declared with the `var` keyword, with the **name**, an **equals sign** and the **value** following

<br>

> There are no types, rather the variables are declared dynamically



```swift
var name = "acho"
var number = 10
var condition = true

var array = [10, 20, 30, 40]
var arrayValue = array[1]
```


<br>

> Everywhere, where a value must be put in, calculations are possible

```swift
var num1 = 10
var num2 = 20

var num3 = (num1 + num2) * 2

log num3 + 1

// CONSOLE
61
```

<br>

---

<br>

## Comparisons

You can compare two values with these keywords:

- `==`
    
    ```swift
    log 10 == 10
    log "Hello" == "World"
    log 1 == 2

    // CONSOLE
    true
    false
    false
    ```
- `> <`

    ```swift
    log 10 < 15
    log 20 > 30

    log 10 >= 10
    log 10 <= 30 

    // CONSOLE
    true
    false
    true
    true
- `&&`

    ```swift
    log 10 == 10 && 20 == 20
    log 1 > 2 && 10 == 10

    // CONSOLE
    true
    false
    ```

> Note that all these return boolean values and should be used for 

<br><br>

## Conditions

**Conditions** can be used with the `if` keyword

> Note that Kang2 doesn't use parenthesis, unlike other languages

```swift
if 10 == 10 {
    log "hello"
}

if input "what is your name?" == "acho" {
    log "hello acho!"
}

```

<br>

Get an **else if** with the `elseif`- and a final **else** statement with the `else` keyword

```swift
if 10 == 20 {
    log "5 + 5 = 20"
} elseif 10 == 30{
    log "5 + 5 = 30"
} else {
    log "omg"
}
```

<br>

---

<br>

## Loops
The `loop` keyword is needed, to use **loops**

<br>

> To **loop** for a specific amount of times, just a that number is necessary

```swift
    loop 3 {
        log "Hello"
    }

    // CONSOLE
    "Hello"
    "Hello"
    "Hello"
```

<br>

> Unlike other programmming languages, the there is no **for-** and **while**, rather the `loop` combines both of those COMING SOON

<br>

---

<br>

## Functions

**Functions** are created, with the `func` keyword.

```swift
func giveName() {
    log "Hello my name is gustavo"
}

func call(name) {
    log "But you can call me " + name
}

func getName() {
    return "gus"
}

var name = getName()

giveName()
call(name)

// CONSOLE
 
"Hello my name is gustavo"
"But you can call me gus"
```

Returning can also be done with the **arrow**. Here it assigns the Variable by itself and returns it in the end by itself too.

```swift
func add(num1, num2) -> var sum {
    sum = num1 + num2
}

log sum(10, 20)

// CONSOLE

30
```

<br>

---

<br>

## Summary

Kang2 is best used either as a toolbox for someone interested in the inner workings of programming languages or someone who is an absolute beginner, due to there being some features catered to those people.

In the end it's just a student project and shouldn't be taken to seriously. The language doesn't go to deep and isn't really meant to be adapted into the mainstream, but the ideas themselves could be.

This was created by AchoDev between 2021-2022